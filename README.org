#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:2 p:nil pri:nil prop:nil
#+OPTIONS: stat:t tags:t tasks:t tex:t timestamp:t title:t toc:2
#+OPTIONS: todo:t |:t
#+TITLE: Org Babel Git Utilities
#+DATE: <2015-10-14 09:19:08 Wednesday>
#+AUTHOR: George M Jones
#+EMAIL: gmj@pobox.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.0.50.1 (Org mode 8.3beta)

* Introduction

#+begin_quote
If it's not in git, it does not exist.

--Me
#+end_quote

This is a set of Emacs org babel utilities to facilitate making that
goal a reality.

The model envisioned here is that there will be a base directory
(BASEDIR), possibly your =$(HOME)= directory or something like
=~/projects= with other directories below it, most/all of which should
be under git control.

The [[*Actions][Actions]] listed below will currently do the following:

- find all repos unde BASEDIR
- list the remotes (or lack of them) for each repo
- Add .dir-locals.el to each repo for use with https://github.com/ryuslash/git-auto-commit-mode
- Find recently modified files (last RECENT days) that are not in a
  git repo or not in a directory listed to be ignored (IGNOREDIRS)

For those not familiar with Babel, see
http://orgmode.org/worg/org-contrib/babel/intro.html.  Short version,
it allows you to run code blocks (bash, python, lisp....) like this

#+begin_example
#+begin_src sh  :results output :exports both
exec 2>&1;date;set -e; set -u; set -x

echo hello world
#+end_src

#+end_example

#+begin_src sh  :results output :exports results
exec 2>&1;date;set -e; set -u; set -x

echo hello world
#+end_src

inside emacs .org files by simply typing ^C^C, getting results like this:

#+RESULTS:
: Sat Oct 10 13:47:28 EDT 2015
: + echo hello world
: hello world

* Configuration
  First, set the variables below as appropriate:

  - BASEDIR :: defines the root of all potentially git controlled
       files.
       
  - RECENT :: defines the number of days that define "recent"
        modification. 
  - MAXLINES :: defined the maximum number of lines to display   
  - IGNOREDIRS :: (if it exists) lists a file in BASEDIR that
        contains   directory names to ignore.

  NOTE: Org Babel seems to take the first definition of a =#+NAME:=.     

    #+NAME: BASEDIR
    | /home/george/projects/current                                |


    #+NAME: BASEDIR
    | /home/george/git/github.com/eludom/ |


    #+NAME: IGNOREDIRS
    | org-bable-git-utils-ignore-dirs.txt |

    #+NAME: RECENT
    | 180 |

    #+NAME: MAXLINES
    | 100 |


You might have to put something like this in your =~/.emacs.d/init.el:

#+begin_src  lisp
(org-babel-do-load-languages
    'org-babel-load-languages '((python . t) (sh . t) (lisp . t) (R . t) (ditaa . t)))
(setq org-export-babel-evaluate nil)
(setq org-confirm-babel-evaluate nil)
#+end_src

* Actions
** DONE List git repos starting from a BASEDIR

   Run this. then ask yourself "Can I get rid of any of
   these repos" ?  If you can, delete, move them or get rid of the
   .git/ directory so they will be ignored

 #+name: GIT-DIRS
 #+begin_src sh  :results table :exports both :var basedir=BASEDIR :var ignoredirs=IGNOREDIRS
 exec 2>&1;set -e; set -u; set +x
 cd $basedir ||  echo "cd $basedir failed"

 if [ -f $ignoredirs ]; then
   #echo ignoring files in $ignoredirs
   find `pwd` -name .git -print | egrep -v -f $ignoredirs
 else
   #echo nothing to skip
   find `pwd` -name .git -print 
 fi
   

 #+end_src

 #+RESULTS: GIT-DIRS
 | /home/george/projects/current/backups/.git             |
 | /home/george/projects/current/daniel/.git              |
 | /home/george/projects/current/home/.git                |
 | /home/george/projects/current/org-babel-git-utils/.git |

** DONE List current remotes for each git repo

   If a directory is listed with no remote, the decision needs to be
   made to ignore this, or create a (possibly) remote repo and add
   it.

 #+name: git-files-and-repos
 #+begin_src sh   :exports both  :var gitdirs=GIT-DIRS :results verbatim drawer
 echo gitdir remote1 url1 type1 remote2 url2 type2 | sed 's/^/|/;s/ /|/g'
 echo "|-"
 for gitdir in $gitdirs; do
   dirname=`dirname $gitdir` || true
   cd $dirname || true
   REMOTES=`git remote -v`  || true
   echo $gitdir $REMOTES | sed 's/^/|/;s/ /|/g' || true
 done
 #+end_src

 #+RESULTS: git-files-and-repos
 :RESULTS:
 | gitdir                                                 | remote1 | url1                                                          | type1   | remote2 | url2                                                          | type2  |
 |--------------------------------------------------------+---------+---------------------------------------------------------------+---------+---------+---------------------------------------------------------------+--------|
 | /home/george/projects/current/backups/.git             | origin  | ssh://git-codecommit.us-east-1.amazonaws.com/v1/repos/backups | (fetch) | origin  | ssh://git-codecommit.us-east-1.amazonaws.com/v1/repos/backups | (push) |
 | /home/george/projects/current/daniel/.git              | origin  | ssh://gmj@port111.com/home/gmj/git/daniel.git                 | (fetch) | origin  | ssh://gmj@port111.com/home/gmj/git/daniel.git                 | (push) |
 | /home/george/projects/current/home/.git                | origin  | ssh://gmj@port111.com/home/gmj/git/home                       | (fetch) | origin  | ssh://gmj@port111.com/home/gmj/git/home                       | (push) |
 | /home/george/projects/current/org-babel-git-utils/.git | origin  | git@github.com:eludom/org-babel-git-utils.git                 | (fetch) | origin  | git@github.com:eludom/org-babel-git-utils.git                 | (push) |
 :END:

** DONE List need to push/pull repos (in sync with remote?)

  -  Determine if git push or pull is needed for each repo

  - If you see something like

    #+begin_example
    fatal: No upstream configured for branch 'master'
    fatal: No upstream configured for branch 'master'
    | /home/gmj/git/../foo |bash: line 51: [: bbefddf8d6c5233a9789afd550940ce39d74557e: unary operator expected
    #+end_example

    Look a
    http://unix.stackexchange.com/questions/66548/git-pull-from-remote-but-no-such-ref-was-fetched
    to resolve.  I think

    #+begin_example
    git pull
    git status
    #git add if needed
    #git commit if needed
    git push -u is the answer
    #+end_example

 #+name: git-pull
 #+begin_src sh   :exports both  :var gitdirs=GIT-DIRS :results verbatim drawer
 exec 2>&1;set -e; set -u; set +x
 echo "|gitdir | push or pull "
 echo "|-"
 breakAfter=999
 howMany=0
 for gitdir in $gitdirs; do
   dirname=`dirname $gitdir` || true
   cd $dirname || true
   #REMOTES=`git remote -v`  || true
   #echo $gitdir $REMOTES | sed 's/^/|/;s/ /|/g' || true

   # Source: http://stackoverflow.com/questions/3258243/git-check-if-pull-needed

   git fetch  --all | grep -v Fetching || true

   LOCAL=$(git rev-parse @) || true
   REMOTE=$(git rev-parse @{u}) || true
   BASE=$(git merge-base @ @{u}) || true

   echo -n "| $dirname |"
   if [ $LOCAL = $REMOTE ]; then
     echo "Up-to-date (LOCAL $LOCAL = REMOTE $REMOTE)"
   elif [ $LOCAL = $BASE ]; then
     echo "Need to pull (LOCAL $LOCAL = BASE $BASE)"
   elif [ $REMOTE = $BASE ]; then
     echo "Need to push (REMOTE $REMOTE = BASE $BASE)"
   else
     echo "Diverged"
   fi
   howMany=$((howMany+1))
   if [ $howMany -eq $breakAfter ]; then
     break
   fi
 done
 #+end_src

 #+RESULTS: git-pull
 :RESULTS:
 | gitdir                                            | push or pull                                                                                                  |
 |---------------------------------------------------+---------------------------------------------------------------------------------------------------------------|
 | /home/george/projects/current/backups             | Up-to-date (LOCAL 0a9c5e4acb4c386f6adc422bb865f49a1aa732ef = REMOTE 0a9c5e4acb4c386f6adc422bb865f49a1aa732ef) |
 | /home/george/projects/current/daniel              | Up-to-date (LOCAL 81bf6b01db0acbd5c8602b4956b25d83f259af1c = REMOTE 81bf6b01db0acbd5c8602b4956b25d83f259af1c) |
 | /home/george/projects/current/home                | Up-to-date (LOCAL b5aa51a20532e851682fcbe6fe941e6414323c45 = REMOTE b5aa51a20532e851682fcbe6fe941e6414323c45) |
 | /home/george/projects/current/org-babel-git-utils | Up-to-date (LOCAL dcd5e5f5ec753308adc359dfc4ab4e39d926b4be = REMOTE dcd5e5f5ec753308adc359dfc4ab4e39d926b4be) |
 :END:

** TODO List number of modified files per repo (need to git add/commit)

  -  Determine if we need to do git add/commit.

  - then maybe do something like

    #+begin_example
    git add `git ls-files -m`;git commit -msync;git push    
    #+end_example

    TODO:
      - add =ls-files -m= file output to the table below (maybe first N)    
      - create another action to do pull/add/commit/push

 #+name: git-modified
 #+begin_src sh   :exports both  :var gitdirs=GIT-DIRS :results verbatim drawer
 exec 2>&1;set -e; set -u; set +x
 echo "|gitdir | modified count "
 echo "|-"
 breakAfter=999
 howMany=0
 for gitdir in $gitdirs; do
   dirname=`dirname $gitdir` || true
   cd $dirname || true
   #REMOTES=`git remote -v`  || true
   #echo $gitdir $REMOTES | sed 's/^/|/;s/ /|/g' || true

   # Source: http://stackoverflow.com/questions/3258243/git-check-if-pull-needed
 
   echo -n "| $dirname |"

   modifiedCount=`git ls-files -m | wc -l`

   echo ${modifiedCount}
 
   howMany=$((howMany+1))
   if [ $howMany -eq $breakAfter ]; then
     break
   fi
 done
 #+end_src

 #+RESULTS: git-modified
 :RESULTS:
 | gitdir                                            | modified count |
 |---------------------------------------------------+----------------|
 | /home/george/projects/current/backups             |              0 |
 | /home/george/projects/current/daniel              |              0 |
 | /home/george/projects/current/home                |              1 |
 | /home/george/projects/current/org-babel-git-utils |              1 |
 :END:

** DONE Find recently modified files not in git

    Find recently modified files under the base directory that are not
    in git controlled directories.

    From here, the decision must be made to add directories to git
    control, or put them in the IGNOREDIRS

  #+name: find-recently-modified-files-not-in-git
  #+begin_src sh  :results table :exports both  :var gitdirs=GIT-DIRS :var basedir=BASEDIR :var recent=RECENT :var maxlines=MAXLINES :var ignoredirs=IGNOREDIRS

  # Crate a list of git controlled directorories
  cd $basedir
  cp /dev/null git-controlled-dirs.txt

  for gitdir in $gitdirs; do
    dirname=`dirname $gitdir` || true
    echo $dirname >> git-controlled-dirs.txt
  done

  #echo GIT-CONTROLLED-DIRS
  #cat git-controlled-dirs.txt

  cat git-controlled-dirs.txt > ignore-these-dirs.txt

  if [ -f $ignoredirs ]; then
    cat $ignoredirs >> ignore-these-dirs.txt 
  fi

  #echo IGNORE ignore-these-dirs.txt
  #cat ignore-these-dirs.txt

  # Find files modified "recently"

  find `pwd` -mtime -$recent -print > recently-modified-files.txt || true
#  echo FILES-RECENTLY-MODIFIED
#  cat recently-modified-files.txt || true

  # List recently modified files not in git controlled directories

  echo FILES-RECENTLY-MODIFIED-NOT-IN-GIT-DIRS
  egrep -v -f ignore-these-dirs.txt recently-modified-files.txt | head -$maxlines
  
  #+end_src


** WAITING Make sure things are checked in/out of git automatically

   I'm using git-auto-commit-mode
   https://github.com/ryuslash/git-auto-commit-mode in emacs, which
   automatically does a commit for every file save, optionally
   prompting for commit message and pushing to the  upstream.  This
   may be a little extreme, but maybe not....

   This script makes sure each git controlled directory has the
   requisite =.dir-locals.el= file.
    
 #+name: git-autocommit-setup
 #+begin_src sh  :results output :exports both  :var gitdirs=GIT-DIRS
 echo dirname 
 for gitdir in $gitdirs; do
   dirname=`dirname $gitdir` || true
   file="${dirname}/.dir-locals.el"

   if [ -f ${file} ]; then
     echo ${file} already exists
   else
     echo ${file} does not exist. Creating.
     echo '((nil . ((eval git-auto-commit-mode 1))))' > ${file}
   fi
 done
 #+end_src

 #+RESULTS: git-autocommit-setup
 : dirname
 : /home/george/projects/current/daniel/.dir-locals.el already exists
 : /home/george/projects/current/home/.dir-locals.el already exists
 : /home/george/projects/current/org-git-utils/.dir-locals.el already exists

* Caveats
  - Using shell in babel is sometimes fragile.   Debugging often
    involves adding =|| true= to the end of commands to get the error
    messages.
  - There will only be one file in the org-git-utils repo.  Since org bable
    files are self documenting, and github has some level of support
    for org files, I will post a version of this as the README.org,
    and check in another version as the file in the repo.   I expect
    that the README will quickly dated as I continue to use and
    improve the actual org-git-utils.org.   From time to time, I may
    update the README, but you should pull the org-git-utils file from
    the repo to actually use. 



